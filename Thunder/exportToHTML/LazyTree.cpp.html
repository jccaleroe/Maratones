<html>
<head>
<title>LazyTree.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(128,128,0); }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,128); font-weight: bold; }
.s5 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
LazyTree.cpp</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">//0 p q v - you have to add v to all numbers in the range of p to q (inclusive), where p and q are two indexes of the array.</span><span class="s1"> 
</span><span class="s0">//1 p q - output a line containing a single integer which is the sum of all the array elements between p and q (inclusive)</span><span class="s1"> 
 
</span><span class="s2">#include</span><span class="s3">&lt;bits/stdc++.h&gt;</span><span class="s1"> 
 
</span><span class="s4">using namespace </span><span class="s1">std; 
 
</span><span class="s4">long long </span><span class="s1">*p; 
 
</span><span class="s4">struct </span><span class="s1">SegmentTree{ 
    SegmentTree *L, *R; 
    </span><span class="s4">long long </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">; 
    </span><span class="s4">long long </span><span class="s1">lazy = </span><span class="s5">0</span><span class="s1">; 
    </span><span class="s4">int </span><span class="s1">l, r; 
 
    </span><span class="s4">long long </span><span class="s1">query2(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">b){ 
        </span><span class="s4">if</span><span class="s1">(a == l &amp;&amp; b == r) </span><span class="s4">return </span><span class="s1">sum; 
        </span><span class="s4">if</span><span class="s1">(b &lt;= L-&gt;r) </span><span class="s4">return </span><span class="s1">L-&gt;query(a,b); 
        </span><span class="s4">if</span><span class="s1">(a &gt;= R-&gt;l) </span><span class="s4">return </span><span class="s1">R-&gt;query(a,b); 
        </span><span class="s4">return </span><span class="s1">(L-&gt;query2(a,L-&gt;r) + R-&gt;query2(R-&gt;l, b)); 
    } 
 
    </span><span class="s4">void </span><span class="s1">update(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">val){ 
        </span><span class="s4">if</span><span class="s1">(l == r){ 
            sum += val; 
            </span><span class="s4">return</span><span class="s1">; 
        } 
        </span><span class="s4">int </span><span class="s1">mid = (l + r)/</span><span class="s5">2</span><span class="s1">; 
        </span><span class="s4">if</span><span class="s1">(l &lt;= a &amp;&amp; a&lt;= mid) 
            L-&gt;update(a, val); 
        </span><span class="s4">else</span><span class="s1"> 
            R-&gt;update(a, val); 
        sum = L-&gt;sum + R-&gt;sum; 
    } 
 
    </span><span class="s4">void </span><span class="s1">updateRange2(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">b, </span><span class="s4">long long </span><span class="s1">val){ 
        </span><span class="s4">if</span><span class="s1">(b &lt; l </span><span class="s4">or </span><span class="s1">a &gt; r) 
            </span><span class="s4">return</span><span class="s1">; 
        </span><span class="s4">if</span><span class="s1">(l == r){ 
            sum += val; 
            </span><span class="s4">return</span><span class="s1">; 
        } 
        L-&gt;updateRange2(a, b, val); 
        R-&gt;updateRange2(a,b,val); 
        sum = L-&gt;sum + R-&gt;sum; 
    } 
 
    </span><span class="s4">void </span><span class="s1">updateRange(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">b, </span><span class="s4">long long </span><span class="s1">val){ 
        </span><span class="s4">if</span><span class="s1">(lazy != </span><span class="s5">0</span><span class="s1">){ 
            sum += (r-l+</span><span class="s5">1</span><span class="s1">)*lazy; 
            </span><span class="s4">if</span><span class="s1">(l != r){ 
                R-&gt;lazy = lazy + R-&gt;lazy; 
                L-&gt;lazy = lazy + L-&gt;lazy; 
            } 
            lazy = </span><span class="s5">0</span><span class="s1">; 
        } 
        </span><span class="s4">if</span><span class="s1">(b &lt; l </span><span class="s4">or </span><span class="s1">a &gt; r) 
            </span><span class="s4">return</span><span class="s1">; 
        </span><span class="s4">if</span><span class="s1">(l &gt;= a &amp;&amp; r &lt;= b){ 
            sum += (r-l+</span><span class="s5">1</span><span class="s1">)*val; 
            </span><span class="s4">if</span><span class="s1">(l != r){ 
                R-&gt;lazy = val + R-&gt;lazy; 
                L-&gt;lazy = val + L-&gt;lazy; 
            } 
            </span><span class="s4">return</span><span class="s1">; 
        } 
        L-&gt;updateRange(a, b, val); 
        R-&gt;updateRange(a,b,val); 
        sum = L-&gt;sum + R-&gt;sum; 
    } 
 
    </span><span class="s4">long long </span><span class="s1">query(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">b){ 
        </span><span class="s4">if</span><span class="s1">(b &lt; l </span><span class="s4">or </span><span class="s1">a &gt; r) 
            </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
        </span><span class="s4">if</span><span class="s1">(lazy != </span><span class="s5">0</span><span class="s1">){ 
            sum += (r-l+</span><span class="s5">1</span><span class="s1">)*lazy; 
            </span><span class="s4">if</span><span class="s1">(l != r){ 
                R-&gt;lazy = lazy + R-&gt;lazy; 
                L-&gt;lazy = lazy + L-&gt;lazy; 
            } 
            lazy = </span><span class="s5">0</span><span class="s1">; 
        } 
        </span><span class="s4">if</span><span class="s1">(a == l &amp;&amp; b == r) </span><span class="s4">return </span><span class="s1">sum; 
        </span><span class="s4">if</span><span class="s1">(b &lt;= L-&gt;r) </span><span class="s4">return </span><span class="s1">L-&gt;query(a,b); 
        </span><span class="s4">if</span><span class="s1">(a &gt;= R-&gt;l) </span><span class="s4">return </span><span class="s1">R-&gt;query(a,b); 
        </span><span class="s4">return </span><span class="s1">(L-&gt;query(a,L-&gt;r) + R-&gt;query(R-&gt;l, b)); 
    } 
 
    SegmentTree(</span><span class="s4">int </span><span class="s1">a, </span><span class="s4">int </span><span class="s1">b): l(a), r(b){ 
        </span><span class="s4">if</span><span class="s1">(a == b){ 
            sum = p[a]; 
            L = R = </span><span class="s4">nullptr</span><span class="s1">; 
        } 
        </span><span class="s4">else</span><span class="s1">{ 
            L = </span><span class="s4">new </span><span class="s1">SegmentTree ( a, (a+b)/</span><span class="s5">2 </span><span class="s1">); 
            R = </span><span class="s4">new </span><span class="s1">SegmentTree ( (a+b)/</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">, b ); 
            sum = L-&gt;sum + R-&gt;sum; 
        } 
    } 
}; 
 
</span><span class="s4">int </span><span class="s1">main(){ 
    </span><span class="s4">long long </span><span class="s1">T; 
    cin &gt;&gt; T; 
    </span><span class="s4">while</span><span class="s1">(T--){ 
        </span><span class="s4">long long </span><span class="s1">n, c; 
        cin &gt;&gt; n &gt;&gt; c; 
        </span><span class="s4">long long </span><span class="s1">l[n]; 
        memset(l,</span><span class="s5">0</span><span class="s1">,</span><span class="s4">sizeof</span><span class="s1">(l)); 
        p = l; 
        SegmentTree *stree = </span><span class="s4">new </span><span class="s1">SegmentTree(</span><span class="s5">0</span><span class="s1">, n-</span><span class="s5">1</span><span class="s1">); 
        </span><span class="s4">while</span><span class="s1">(c--){ 
            </span><span class="s4">long long </span><span class="s1">aux, p, q; 
            cin &gt;&gt; aux &gt;&gt; p &gt;&gt; q; 
            </span><span class="s4">if</span><span class="s1">(aux == </span><span class="s5">0</span><span class="s1">){ 
                </span><span class="s4">long long </span><span class="s1">val; 
                cin &gt;&gt; val; 
                stree-&gt;updateRange(p-</span><span class="s5">1</span><span class="s1">, q-</span><span class="s5">1</span><span class="s1">, val); 
            } 
            </span><span class="s4">else</span><span class="s1"> 
                cout &lt;&lt; stree-&gt;query(p-</span><span class="s5">1</span><span class="s1">, q-</span><span class="s5">1</span><span class="s1">) &lt;&lt; endl; 
        } 
    } 
} 
</span></pre>
</body>
</html>