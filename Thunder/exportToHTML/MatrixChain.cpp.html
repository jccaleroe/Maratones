<html>
<head>
<title>MatrixChain.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(128,128,0); }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,128); font-weight: bold; }
.s5 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
MatrixChain.cpp</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">// See the Cormen book for details of the following algorithm</span><span class="s1"> 
</span><span class="s2">#include</span><span class="s3">&lt;stdio.h&gt;</span><span class="s1"> 
</span><span class="s2">#include</span><span class="s3">&lt;limits.h&gt;</span><span class="s1"> 
 
</span><span class="s4">int </span><span class="s1">MatrixChainOrderR(</span><span class="s4">int </span><span class="s1">p[], </span><span class="s4">int </span><span class="s1">i, </span><span class="s4">int </span><span class="s1">j) { 
    </span><span class="s4">if</span><span class="s1">(i == j) 
        </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
    </span><span class="s4">int </span><span class="s1">k; 
    </span><span class="s4">int </span><span class="s1">min = INT_MAX; 
    </span><span class="s4">int </span><span class="s1">count; 
 
    </span><span class="s0">// place parenthesis at different places between first</span><span class="s1"> 
    </span><span class="s0">// and last matrix, recursively calculate count of</span><span class="s1"> 
    </span><span class="s0">// multiplications for each parenthesis placement and</span><span class="s1"> 
    </span><span class="s0">// return the minimum count</span><span class="s1"> 
    </span><span class="s4">for </span><span class="s1">(k = i; k &lt;j; k++) { 
        count = MatrixChainOrderR(p, i, k) + 
                MatrixChainOrderR(p, k+</span><span class="s5">1</span><span class="s1">, j) + 
                p[i-</span><span class="s5">1</span><span class="s1">]*p[k]*p[j]; 
         
        </span><span class="s4">if </span><span class="s1">(count &lt; min) min = count; 
    } 
 
    </span><span class="s0">// Return minimum count</span><span class="s1"> 
    </span><span class="s4">return </span><span class="s1">min; 
} 
 
</span><span class="s0">// Matrix Ai has dimension p[i-1] x p[i] for i = 1..n</span><span class="s1"> 
</span><span class="s4">int </span><span class="s1">MatrixChainOrder(</span><span class="s4">int </span><span class="s1">p[], </span><span class="s4">int </span><span class="s1">n) { 
    </span><span class="s0">/* For simplicity of the program, one extra row and one 
       extra column are allocated in m[][].  0th row and 0th 
       column of m[][] are not used */</span><span class="s1"> 
    </span><span class="s4">int </span><span class="s1">m[n][n]; 
 
    </span><span class="s4">int </span><span class="s1">i, j, k, L, q; 
 
    </span><span class="s0">/* m[i,j] = Minimum number of scalar multiplications needed 
       to compute the matrix A[i]A[i+1]...A[j] = A[i..j] where 
       dimension of A[i] is p[i-1] x p[i] */</span><span class="s1"> 
 
    </span><span class="s0">// cost is zero when multiplying one matrix.</span><span class="s1"> 
    </span><span class="s4">for </span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">; i&lt;n; i++) m[i][i] = </span><span class="s5">0</span><span class="s1">; 
 
    </span><span class="s0">// L is chain length.</span><span class="s1"> 
    </span><span class="s4">for </span><span class="s1">(L=</span><span class="s5">2</span><span class="s1">; L&lt;n; L++) { 
        </span><span class="s4">for </span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">; i&lt;n-L+</span><span class="s5">1</span><span class="s1">; i++) { 
            j = i+L-</span><span class="s5">1</span><span class="s1">; 
            m[i][j] = INT_MAX; 
            </span><span class="s4">for </span><span class="s1">(k=i; k&lt;=j-</span><span class="s5">1</span><span class="s1">; k++) { 
                </span><span class="s0">// q = cost/scalar multiplications</span><span class="s1"> 
                q = m[i][k] + m[k+</span><span class="s5">1</span><span class="s1">][j] + p[i-</span><span class="s5">1</span><span class="s1">]*p[k]*p[j]; 
                </span><span class="s4">if </span><span class="s1">(q &lt; m[i][j]) 
                    m[i][j] = q; 
            } 
        } 
    } 
 
    </span><span class="s4">return </span><span class="s1">m[</span><span class="s5">1</span><span class="s1">][n-</span><span class="s5">1</span><span class="s1">]; 
} 
 
</span><span class="s4">int </span><span class="s1">main() 
{ 
    </span><span class="s4">int </span><span class="s1">arr[] = {</span><span class="s5">1</span><span class="s1">, </span><span class="s5">2</span><span class="s1">, </span><span class="s5">3</span><span class="s1">, </span><span class="s5">4</span><span class="s1">}; 
    </span><span class="s4">int </span><span class="s1">size = </span><span class="s4">sizeof</span><span class="s1">(arr)/</span><span class="s4">sizeof</span><span class="s1">(arr[</span><span class="s5">0</span><span class="s1">]); 
 
    printf(</span><span class="s3">&quot;Minimum number of multiplications is %d &quot;</span><span class="s1">, 
                       MatrixChainOrder(arr, size)); 
 
    getchar(); 
    </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
}</span></pre>
</body>
</html>